<script setup lang="ts">
import { onMounted, reactive } from "vue";

// 虚拟DOM和diff算法（难懂，建议多看几遍）

// 虚拟DOM出现的原因：频繁DOM 操作非常耗费性能，所以将 DOM 描述为 AST 语法树（render函数），JS计算比较快，计算出差异后，再操作 DOM 更新

// 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。
// Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。
// Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。

// -  初始渲染：Virtual DOM > 脏检查 >= 依赖收集
// -  小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化
// -  大量数据更新：脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM（无法/无需优化）>> MVVM 无优化

// 不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它
// ① 为函数式的 UI 编程方式打开了大门；
// ② 可以渲染到 DOM 以外的 backend，比如 ReactNative。

// AST抽象语法树用在很多地方：（编译器实现的过程中，需要建立抽象语法树）
//    - ts 转 js 时，会进行 AST的转换
//    - babel 在 ES6 转 ES5 的时候，也会进行 AST转换
//    - JS 通过 V8 引擎 转字节码的时候，也会经过 AST 转换

const arr2: string[] = ["A", "B", "C", "D"];
arr2.splice(2, 0, "DDDDD");

const arr: any[] = reactive([1, 2, 3, 4, 5]);

onMounted(() => {
  console.time();
  arr.splice(2, 0, "22222");
  console.timeEnd();
});

// diff算法 源码位置：node_modules/@vue/runtime-core/dist/runtime-core.cjs.prod.js

// vue3 的 diff 算法：（无key）
// 1、patch的时候会全部替换（按照一对一的顺序）
// 2、新节点多的就新增
// 3、旧节点多的就删除

// vue3 的 diff 算法：（有key）
// 1、前序对比算法（只对比前面的，头和头）（相同则进行diff，不同则跳转下一步）
// 2、尾序对比算法（只对比后面的，尾和尾）（相同则进行diff，不同则跳转下一步）
// 3、新节点多出来就是挂载（中间）
// 4、旧节点多出来就是卸载（中间）
// 5、特殊情况乱序（比如 ABC 变成 BCA）：当需要进行移动操作的时候，那么这个问题就变成了求取新旧子树上的【最长递增子序列】
//    5.1、构建新节点的映射关系（Map格式）
//          - 比如：一个列表，key是业务 id 1 2 3 4 5，索引 index 是 0 1 2 3 4
//          - 先进行一个业务id 的 sort排序，排出来是 5 4 3 2 1，索引不变还是 0 1 2 3 4
//          - 那么就会确认一个初始的映射对应关系：5=>0   4=>1  3=>2  2=>3  1=>4
//    5.2、
//          - 首先会记录新节点在旧节点中的位置数组：[5, 4, 3, 2, 1]（个人理解：就是5.1排序后的位置结果对应的数组）
//          - 多余的旧节点进行删除（个人理解：旧 1 2 3 4 5 新 1 2 3，那就把旧的 4 5 删掉）
//          - 如果新节点不包含旧节点也删除（个人理解： 旧 1 2 3 新 1 2 4, 旧节点的 3 不被新节点包含所以删除）
//          - 如果节点出现交叉，说明是要移动，去求【最长递增子序列】（贪心+二分）
//                例子：[10, 9, 2, 5, 3, 7, 101, 18]， - 先默认给一个递增的子序列 dp 都是 1
//                   dp  1  1  1  1  1  1   1   1   ， - 然后从左往右，去对比每个数值是否大于前面每个的数值
//                                                     - 若大于前面 n 个值，则取这n个值中对应的最大的 新dp，加上自身（1）
//                 新dp  1  1  1  2  2  3   4   4      - 若大于前面 0 个值 或 前面没值，则保持自身默认dp（1）不变
//                     - 10 前面没值，保持自身的 1
//                     - 9 < 10，保持自身的 1
//                     - 2 < 9, 2 < 10，保持自身的 1
//                     - 5 > 2, 5 < 9, 5 < 10, 则 将 2对应的 新dp（1）加 自身默认的dp（1），作为自己的序列（2）
//                     - 3 > 2，同上，1+1 = 2
//                     - 7 > 3, 7 > 5, 7 > 2, 这三个中最大的 新dp 是2, 所以 2+1 = 3
//                     - 101 大于前面每一个，其中最大的是 新dp 是3，所以 3+1 = 4
//                     - 18 除了 101 都比得过，其中最大的是 新dp 是3，所以 3+1 = 4

//                     - 最长递增子序列并不唯一，如这里是 2  3(或5)  7  18(或101)
//            - 如果当前遍历的这个节点不在子序列说明要进行移动
//            - 如果节点在序列中直接跳过

// vue2的双端diff算法与vue3不同：（有key）
// 1、头和头
// 2、尾和尾
// 3、头和尾、尾和头（头尾交叉对比）
</script>

<template>
  <div>
    06-------------------------------------------------------------------
  </div>
  <div v-for="item in arr2">
    {{ item }}
  </div>
  <div>
    -----------------------------------------------------------------------
  </div>
</template>
